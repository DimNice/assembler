%include "io64.inc"
section .bss
vec: resd 100
N:resd 1

section .text
global CMAIN
CMAIN:    
    mov rbp, rsp; for correct debugging
    GET_UDEC 4, edx; Ввод числовых данных в 10-чном представлении с клавиатуры размером 4. Считывает беззнаковое число
    mov[N], edx; копирует содержимое ИСТОЧНИКА(edx) и помещает это содержимое в ПРИЁМНИК [N] это адрес ячейки памяти
    mov ecx, 0; счетчик равен 0

loop1: 
    GET_DEC 4, eax; Ввод числовых данных в 10-чном представлении с клавиатуры размером 4. Считывает знаковое число
    mov[vec+4*ecx], eax; копирует содержимое ИСТОЧНИКА(eax)счетчик и помещает это содержимое в ПРИЁМНИК(типа массив заполняется?)
    inc ecx; увеличиваем счетчик на 1
    cmp ecx,[N]; проверка на равенство
    jnz loop1
    
    mov r10d, [N]; копирует содержимое ИСТОЧНИКА(N) и помещает это содержимое в ПРИЁМНИК r10 
    dec r10; уменьшаем на 1
    xor r8,r8
    xor r9,r9    ; j
    xor r12, r12 ; i
    xor r13, r13 ; min
for_i:
    mov eax, [vec+r12*4]; принимаем за минимум первый элемент неотсортированной части массива 
    lea r9, [r12+1] ;  помещает в приемник адрес источника
    mov r13, r12

    for_j:
        cmp eax, [vec+r9*4]; сравнивание "минимума" с другими элементами массива
        jng not_min
        mov eax, [vec+r9*4]; если "минимум" оказался не минимумом, то другой элемент им становится
        mov r13,r9; эксперимент запоминания места
        inc r9;переходим к след элементу
        cmp r9, [N]
        jl for_j
    not_min:
        inc r9;переходим к след элементу
        cmp r9, [N]
        jl for_j
        
    xchg [vec+r12*4], eax; в первый элемент неотсортированного массива переносится минимум
    mov [vec+r13*4], eax ; хочу в место где был найден минимум записать первый элемент
    inc r12; сдвиг массива на 1, чтоб не трогать отсортированный
    cmp r12d, r10d
    jl for_i
xor r9,r9
NEWLINE
print:
    PRINT_DEC 4, [vec+4*r9]
    PRINT_STRING ' '
    inc r9,
    cmp r9d, [N]
    jnz print
   xor rax,rax
ret
